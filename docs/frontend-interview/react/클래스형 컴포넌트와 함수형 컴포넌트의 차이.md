---
sidebar_position: 3
---

# 클래스형 컴포넌트와 함수형 컴포넌트의 차이

## React 컴포넌트 패러다임의 진화

### 초기 React의 철학적 배경 (2013-2018)

**객체지향 프로그래밍의 영향**
React 초기 설계는 Java, C# 등 객체지향 언어의 클래스 개념에 많은 영향을 받았습니다. Facebook의 개발팀은 이미 객체지향에 익숙한 개발자들이 쉽게 접근할 수 있도록 클래스 기반 컴포넌트를 중심으로 설계했습니다.

**상태와 동작의 캡슐화**
클래스형 컴포넌트는 전통적인 객체지향의 핵심 개념인 "상태(state)와 동작(method)을 하나의 단위로 캡슐화"하는 철학을 반영했습니다. 컴포넌트는 마치 살아있는 객체처럼 자신만의 상태를 가지고, 그 상태를 조작하는 메서드들을 포함했습니다.

**생명주기의 명시적 관리**
초기 React는 컴포넌트의 생명주기를 매우 명시적으로 관리했습니다. 각 단계(마운트, 업데이트, 언마운트)에 대응하는 명확한 메서드들을 제공함으로써, 개발자가 컴포넌트의 생명주기를 세밀하게 제어할 수 있게 했습니다.

### Hook 도입의 철학적 전환 (2018-현재)

**함수형 프로그래밍으로의 패러다임 전환**
React 팀은 점차 함수형 프로그래밍의 장점을 인식하기 시작했습니다. 함수형 접근법의 핵심은 "부작용을 최소화하고, 예측 가능한 결과를 보장하는 것"이었습니다.

**컴포넌트를 함수로 보는 관점**
Hook의 도입은 "컴포넌트는 props를 입력받아 JSX를 반환하는 함수"라는 순수한 함수적 관점으로의 전환을 의미했습니다. 이는 React의 핵심 철학인 "UI = f(state)"를 더욱 명확하게 표현한 것입니다.

**로직 재사용의 새로운 패러다임**
기존의 Higher-Order Component, Render Props 패턴은 복잡하고 이해하기 어려웠습니다. Hook은 이러한 패턴들을 더 간단하고 직관적인 방식으로 대체했습니다.

## 두 패러다임의 근본적 차이점

## 문법과 구조의 차이

### 클래스형 컴포넌트

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }

  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>증가</button>
      </div>
    );
  }
}
```

### 함수형 컴포넌트

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>증가</button>
    </div>
  );
}
```

## 주요 차이점

### 1. 문법의 간결성

**클래스형 컴포넌트**

- ES6 class 문법 사용
- constructor에서 state 초기화 필요
- this 바인딩 문제 고려 필요
- render() 메서드 필수

**함수형 컴포넌트**

- 일반 JavaScript 함수
- Hook을 사용한 간결한 상태 관리
- this 바인딩 불필요
- 단순히 JSX 반환

### 2. 상태 관리 방식

**클래스형 컴포넌트**

- `this.state`와 `this.setState()` 사용
- 상태 업데이트가 비동기적이고 배치로 처리됨
- 복잡한 상태 구조 관리 가능

**함수형 컴포넌트**

- `useState` Hook 사용
- 각 상태가 독립적으로 관리됨
- 상태별로 개별 setter 함수 제공

### 3. 생명주기 관리

**클래스형 컴포넌트**

- 명확한 생명주기 메서드들 제공
  - `componentDidMount`
  - `componentDidUpdate`
  - `componentWillUnmount`
- 각 생명주기별로 다른 로직 수행 가능

**함수형 컴포넌트**

- `useEffect` Hook으로 모든 생명주기 관리
- 의존성 배열로 실행 조건 제어
- 정리(cleanup) 함수로 메모리 누수 방지

### 4. 성능 최적화

**클래스형 컴포넌트**

- `shouldComponentUpdate` 메서드 제공
- `PureComponent` 확장으로 얕은 비교 자동화
- 생명주기 메서드에서 세밀한 제어 가능

**함수형 컴포넌트**

- `React.memo`로 메모이제이션
- `useMemo`, `useCallback`으로 값과 함수 메모이제이션
- Hook을 통한 더 세밀한 최적화 가능

### 5. 메모리 사용량과 성능

**클래스형 컴포넌트**

- 인스턴스 생성으로 인한 메모리 오버헤드
- 생명주기 메서드들이 항상 메모리에 존재
- this 바인딩으로 인한 추가 메모리 사용

**함수형 컴포넌트**

- 함수 호출만으로 실행되어 메모리 효율적
- 필요한 Hook만 실행되어 경량화
- 클로저를 활용한 효율적인 상태 관리

## Hook 도입의 근본적 동기와 철학

### React 팀이 직면한 문제들

**1. 로직 재사용의 어려움**
클래스형 컴포넌트에서 상태 로직을 재사용하는 것은 매우 복잡했습니다. Higher-Order Component(HOC)나 Render Props 패턴을 사용해야 했는데, 이는 "래퍼 지옥(Wrapper Hell)"을 만들어냈습니다.

**2. 복잡한 컴포넌트의 이해 어려움**
생명주기 메서드에 관련 없는 로직들이 섞이는 경우가 많았습니다. 예를 들어, `componentDidMount`에서 데이터 페칭과 이벤트 리스너 등록을 동시에 하는 경우가 흔했습니다.

**3. 클래스의 혼란스러움**
JavaScript의 `this` 바인딩, 메서드 바인딩 등은 많은 개발자들에게 혼란을 가져다주었습니다. 또한 클래스는 컴파일 최적화를 어렵게 만들었습니다.

### Hook이 제시한 새로운 철학

**관심사의 분리 (Separation of Concerns)**
Hook은 생명주기가 아닌 "관심사"별로 로직을 분리할 수 있게 했습니다. 데이터 페칭 로직은 하나의 `useEffect`에, 이벤트 리스너는 다른 `useEffect`에 분리할 수 있게 되었습니다.

**조합을 통한 재사용 (Composition over Inheritance)**
클래스 상속 대신 Hook의 조합을 통해 로직을 재사용할 수 있게 되었습니다. 이는 함수형 프로그래밍의 핵심 원칙 중 하나입니다.

**선언적 부작용 관리**
`useEffect`는 부작용을 선언적으로 관리할 수 있게 해주었습니다. "이 상태가 변경될 때 이 부작용을 실행한다"는 명확한 의존성 관계를 표현할 수 있게 되었습니다.

## Hook이 가져온 메커니즘의 혁신

### 클로저를 활용한 상태 관리

**클래스형 컴포넌트의 상태 관리**
클래스형 컴포넌트는 인스턴스 변수로 상태를 관리했습니다. `this.state`는 컴포넌트 인스턴스에 속한 객체였고, 이는 메모리에 지속적으로 존재했습니다.

**함수형 컴포넌트의 클로저 기반 상태 관리**
Hook은 JavaScript의 클로저를 활용해 상태를 관리합니다. 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성되지만, Hook은 이전 상태를 "기억"할 수 있습니다.

이는 React 내부적으로 "Hook 호출 순서"를 통해 상태를 추적하는 메커니즘으로 구현됩니다. 이것이 바로 Hook을 조건문 안에서 호출하면 안 되는 이유입니다.

### 의존성 배열의 철학

**자동 최적화를 위한 명시적 의존성**
`useEffect`, `useMemo`, `useCallback` 등의 의존성 배열은 React가 자동으로 최적화를 수행할 수 있게 해줍니다. 개발자가 명시적으로 "이 값들이 변경될 때만 실행해라"라고 선언하는 것입니다.

**함수형 프로그래밍의 순수성 반영**
의존성 배열은 함수형 프로그래밍의 "순수 함수" 개념을 반영합니다. 함수의 결과가 오직 입력값에만 의존한다는 것을 명시적으로 표현하는 방법입니다.

## 두 패러다임이 반영하는 소프트웨어 철학

### 클래스형 컴포넌트: 객체지향적 사고

**상태와 행동의 통합**
클래스형 컴포넌트는 "데이터(상태)와 그 데이터를 조작하는 메서드를 하나의 단위로 묶는다"는 객체지향의 기본 원칙을 따릅니다.

**상속을 통한 코드 재사용**
React.Component를 상속받아 기능을 확장하는 방식은 전통적인 객체지향 프로그래밍의 상속 패턴을 반영합니다.

**명시적 생명주기 관리**
각 생명주기 단계에 대한 명확한 메서드를 제공하여 개발자가 세밀하게 제어할 수 있게 합니다.

### 함수형 컴포넌트: 함수형 사고

**불변성과 순수성**
함수형 컴포넌트는 props라는 입력을 받아 JSX라는 출력을 반환하는 순수 함수의 개념을 구현합니다.

**조합을 통한 복잡성 관리**
작은 함수들(Hook)을 조합하여 복잡한 로직을 구성하는 것은 함수형 프로그래밍의 핵심 원칙입니다.

**선언적 프로그래밍**
"무엇을 해야 하는가"에 집중하며, "어떻게 해야 하는가"는 Hook이 추상화해줍니다.

## 장단점 비교

### 클래스형 컴포넌트

**장점:**

- 명확하고 직관적인 생명주기 메서드
- 복잡한 상태 로직 관리에 유리
- 에러 바운더리(Error Boundary) 구현 가능
- 기존 개발자들에게 친숙한 OOP 패턴

**단점:**

- 보일러플레이트 코드가 많음
- this 바인딩 문제
- Hook의 유연성 부족
- 번들 크기가 상대적으로 큼

### 함수형 컴포넌트

**장점:**

- 간결하고 읽기 쉬운 코드
- Hook을 통한 유연한 로직 재사용
- 테스트하기 쉬움
- 성능 최적화가 용이
- 함수형 프로그래밍 패러다임

**단점:**

- Hook의 규칙을 지켜야 함
- 클로저로 인한 예상치 못한 동작 가능
- 에러 바운더리 직접 구현 불가 (현재까지)

## 현재 권장사항

### React 팀의 공식 권장사항

- **새로운 프로젝트**: 함수형 컴포넌트 + Hook 사용
- **기존 프로젝트**: 점진적으로 함수형 컴포넌트로 마이그레이션
- **에러 바운더리**: 여전히 클래스형 컴포넌트 필요

### 실무에서의 선택 기준

**함수형 컴포넌트를 선택해야 할 때:**

- 새로운 기능 개발
- 간단하고 명확한 로직
- Hook의 장점을 활용할 수 있는 경우
- 팀에서 함수형 프로그래밍을 선호하는 경우

**클래스형 컴포넌트가 필요할 때:**

- 에러 바운더리 구현
- 복잡한 생명주기 로직이 있는 레거시 코드
- 팀의 기존 코드 스타일과 일관성 유지

## 마이그레이션 가이드

### 클래스형에서 함수형으로 변환하기

**1. 기본 구조 변환**

```jsx
// Before (Class)
class MyComponent extends React.Component {
  render() {
    return <div>Hello</div>;
  }
}

// After (Function)
function MyComponent() {
  return <div>Hello</div>;
}
```

**2. 상태 관리 변환**

```jsx
// Before
this.state = { count: 0 };
this.setState({ count: this.state.count + 1 });

// After
const [count, setCount] = useState(0);
setCount(count + 1);
```

**3. 생명주기 변환**

```jsx
// Before
componentDidMount() {
  // 마운트 시 실행
}

// After
useEffect(() => {
  // 마운트 시 실행
}, []);
```

## 결론

함수형 컴포넌트와 Hook의 조합이 현재 React 개발의 표준이 되었습니다. 코드가 더 간결하고, 로직 재사용이 쉬우며, 성능 최적화가 용이합니다. 하지만 클래스형 컴포넌트도 여전히 특정 상황에서는 필요하므로, 두 방식 모두 이해하고 상황에 맞게 선택할 수 있어야 합니다.

특히 면접에서는 두 방식의 차이점과 각각의 장단점을 명확히 설명할 수 있어야 하며, Hook이 도입된 배경과 그로 인한 React 생태계의 변화를 이해하고 있음을 보여주는 것이 중요합니다.
