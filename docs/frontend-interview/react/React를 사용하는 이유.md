---
sidebar_position: 2
---

# React를 사용하는 이유

## React 탄생의 역사적 배경

### 웹 개발의 진화 과정

**1990년대 후반 - 2000년대 초반: 정적 웹의 시대**
웹은 단순한 문서 공유 목적으로 시작되었습니다. HTML과 CSS만으로 정적인 페이지를 만드는 것이 전부였고, 상호작용은 매우 제한적이었습니다.

**2000년대 중반: AJAX와 동적 웹의 등장**
Gmail, Google Maps 등의 등장으로 웹이 애플리케이션처럼 동작할 수 있다는 가능성이 보여졌습니다. 하지만 이때의 개발 방식은 여전히 서버 중심적이었고, 클라이언트 사이드 로직은 복잡하고 관리하기 어려웠습니다.

**2000년대 후반 - 2010년대 초반: jQuery의 지배**
jQuery가 DOM 조작을 간단하게 만들어 주었지만, 애플리케이션이 복잡해질수록 코드는 스파게티가 되어갔습니다. 상태 관리, 이벤트 처리, DOM 업데이트가 얽히고설켜 유지보수가 악몽이 되었습니다.

### Facebook이 직면한 근본적 문제들

**2010년경, Facebook의 개발팀이 경험한 문제:**

**1. 데이터 흐름의 복잡성**
사용자 인터페이스의 한 부분이 변경되면, 그 영향이 예측할 수 없는 방식으로 다른 부분들에 전파되었습니다. 예를 들어, 메시지 카운터 업데이트가 전혀 관련 없어 보이는 친구 목록에 영향을 주는 일이 발생했습니다.

**2. 상태 불일치 문제**
같은 데이터가 UI의 여러 곳에 표시될 때, 한 곳에서만 업데이트되고 다른 곳은 이전 상태를 유지하는 문제가 빈번했습니다. 사용자가 읽지 않은 메시지 수를 여러 곳에서 보여주는데, 각각이 다른 숫자를 표시하는 상황이 발생했습니다.

**3. 버그 추적의 어려움**
코드의 한 부분을 수정했을 때, 그 변경이 어떤 다른 부분에 영향을 줄지 예측하기 어려웠습니다. 버그를 고치면 새로운 버그가 다른 곳에서 나타나는 "고하고 나면 또 다른 문제" 현상이 일상적이었습니다.

## React가 해결하려 한 철학적 문제

### 명령형 vs 선언형 프로그래밍의 근본적 차이

**명령형 프로그래밍의 한계**
기존 DOM 조작 방식은 "어떻게(How)" 해야 하는지에 집중했습니다. "버튼을 클릭하면 → 요소를 찾고 → 클래스를 추가하고 → 텍스트를 변경하고 → 다른 요소를 업데이트한다"와 같은 방식입니다.

이 방식의 문제점:

- 개발자가 모든 단계를 관리해야 함
- 상태 변화에 따른 모든 UI 업데이트를 직접 처리
- 복잡도가 기하급수적으로 증가

**선언형 프로그래밍의 혁신**
React는 "무엇을(What)" 보여줄지에 집중하게 만들었습니다. "현재 상태에서 UI는 이렇게 생겨야 한다"고 선언하면, React가 알아서 현재 DOM을 목표 상태로 만들어줍니다.

이 철학의 핵심:

- 개발자는 UI의 최종 형태만 기술
- 상태 변화와 UI 업데이트는 React가 담당
- 복잡도가 선형적으로 증가

### 단방향 데이터 흐름의 철학

**양방향 바인딩의 문제점**
Angular 1.x의 양방향 데이터 바인딩은 편리해 보였지만, 데이터가 어디서 변경되는지 추적하기 어려웠습니다. 모델과 뷰가 서로 영향을 주며 변경되다 보니, 디버깅이 매우 어려웠습니다.

**단방향 데이터 흐름의 철학**
React는 "데이터는 위에서 아래로만 흐른다"는 단순하지만 강력한 원칙을 도입했습니다. 이는 다음과 같은 이점을 가져왔습니다:

- **예측 가능성**: 데이터 변경의 흐름을 예측할 수 있음
- **디버깅 용이성**: 문제가 발생하면 데이터 흐름을 역추적할 수 있음
- **테스트 가능성**: 입력이 주어지면 출력을 예측할 수 있음

## React를 선택하는 주요 이유들

### 1. 컴포넌트 기반 아키텍처

**재사용성과 모듈화**
React는 UI를 독립적인 컴포넌트로 나누어 개발할 수 있게 해줍니다. 한 번 만든 컴포넌트는 여러 곳에서 재사용할 수 있어 개발 효율성이 크게 향상됩니다.

**유지보수성**
각 컴포넌트는 독립적인 로직과 상태를 가지므로, 한 부분을 수정해도 다른 부분에 영향을 주지 않습니다. 이는 대규모 애플리케이션에서 특히 중요합니다.

**협업 용이성**
컴포넌트 단위로 개발을 나누어 진행할 수 있어, 여러 개발자가 동시에 작업하기 쉽습니다.

### 2. Virtual DOM을 통한 성능 최적화의 근본 원리

**DOM 조작의 근본적 비용**
실제 DOM은 브라우저의 렌더링 엔진과 밀접하게 연결되어 있습니다. DOM 요소 하나를 변경해도 브라우저는 다음과 같은 복잡한 과정을 거칩니다:

- 스타일 재계산 (Recalculate Style)
- 레이아웃 재배치 (Reflow)
- 화면 다시 그리기 (Repaint)
- 레이어 합성 (Composite)

이 과정은 CPU 집약적이며, 여러 번 발생하면 성능 저하가 심각해집니다.

**Virtual DOM의 철학적 접근**
Virtual DOM은 "실제 DOM 조작은 최대한 적게, 하지만 개발자는 이를 신경 쓰지 않게" 만들자는 철학에서 출발했습니다.

핵심 아이디어:

- JavaScript 객체 조작은 DOM 조작보다 수백 배 빠름
- 메모리에서 "이상적인 DOM 구조"를 시뮬레이션
- 실제 DOM과의 차이점만을 계산하여 최소 변경
- 변경사항을 배치로 처리하여 브라우저 렌더링 최적화

**배치 업데이트의 심층 원리**
React는 상태 변경을 즉시 DOM에 반영하지 않습니다. 대신 "렌더링 큐"에 변경사항을 모아두었다가, 적절한 시점에 한 번에 처리합니다. 이는 브라우저의 프레임 기반 렌더링과 조화를 이룹니다.

### 3. 선언적 프로그래밍

**직관적인 코드**
"어떻게"가 아닌 "무엇을" 중심으로 UI를 기술할 수 있습니다. 상태가 변경되면 그에 맞는 UI가 자동으로 업데이트됩니다.

**예측 가능한 동작**
데이터의 흐름이 단방향이므로 애플리케이션의 동작을 예측하기 쉽고, 디버깅이 용이합니다.

### 4. 풍부한 생태계

**활발한 커뮤니티**
전 세계적으로 많은 개발자들이 사용하고 있어, 문제 해결을 위한 자료와 도구가 풍부합니다.

**다양한 라이브러리**
상태 관리(Redux, Zustand), 라우팅(React Router), UI 라이브러리(Material-UI, Ant Design) 등 다양한 써드파티 라이브러리들이 잘 발달되어 있습니다.

**도구 지원**
React DevTools, Create React App, Next.js 등 개발을 도와주는 강력한 도구들이 제공됩니다.

### 5. 기업 지원과 안정성

**Meta(Facebook) 지원**
Meta에서 지속적으로 개발하고 유지보수하고 있어 안정성과 지속성이 보장됩니다.

**대규모 서비스 검증**
Facebook, Instagram, Netflix, Airbnb 등 수많은 대규모 서비스에서 검증된 기술입니다.

### 6. 학습 곡선과 개발 경험

**상대적으로 쉬운 학습**
JavaScript를 알고 있다면 비교적 쉽게 학습할 수 있습니다. JSX 문법도 HTML과 비슷해서 친숙합니다.

**뛰어난 개발자 경험**
Hot Reloading, 명확한 에러 메시지, 풍부한 디버깅 도구 등으로 개발 경험이 우수합니다.

### 7. 확장성과 유연성

**점진적 도입 가능**
기존 프로젝트에 부분적으로 도입할 수 있어, 전체를 한 번에 바꿀 필요가 없습니다.

**다양한 플랫폼 지원**
React Native를 통해 모바일 앱 개발도 가능하고, Next.js로 서버 사이드 렌더링도 지원합니다.

### 8. 현대적인 개발 패턴

**함수형 프로그래밍 지원**
Hook을 통해 함수형 컴포넌트에서도 상태 관리와 생명주기를 다룰 수 있어, 더 간결하고 테스트하기 쉬운 코드를 작성할 수 있습니다.

**TypeScript 지원**
TypeScript와의 훌륭한 호환성으로 타입 안정성을 확보할 수 있습니다.

## 다른 프레임워크와의 비교에서 React의 장점

### vs jQuery

- 선언적 vs 명령적 프로그래밍
- 컴포넌트 기반 vs DOM 조작 중심
- 상태 관리의 체계화

### vs Angular

- 학습 곡선이 더 완만함
- 더 유연하고 자유로운 구조
- 더 작은 번들 크기

### vs Vue

- 더 큰 생태계와 커뮤니티
- 대규모 애플리케이션에서의 검증된 성능
- 더 많은 취업 기회

## React의 패러다임 전환이 가져온 근본적 변화

### 사고방식의 전환

**기존 방식: 이벤트 중심 사고**
개발자는 "사용자가 버튼을 클릭하면 → 이 함수를 실행하고 → 저 요소를 변경하고 → 다른 곳도 업데이트한다"와 같이 절차적으로 생각해야 했습니다.

**React 방식: 상태 중심 사고**
개발자는 "현재 상태가 이러면 → UI는 이렇게 보여야 한다"고 선언적으로 생각합니다. 상태 변경과 UI 업데이트 사이의 복잡한 과정은 React가 처리합니다.

### 컴포넌트라는 개념의 혁신

**기존의 페이지 중심 개발**
웹 개발은 전통적으로 "페이지"라는 단위로 이루어졌습니다. 각 페이지는 독립적이었고, 공통 기능을 재사용하기 어려웠습니다.

**React의 컴포넌트 중심 개발**
React는 UI를 "컴포넌트"라는 독립적인 단위로 분해했습니다. 이는 다음과 같은 근본적 변화를 가져왔습니다:

- **캡슐화**: 각 컴포넌트는 자신만의 로직과 상태를 가짐
- **조합성**: 작은 컴포넌트들을 조합하여 복잡한 UI 구성
- **추상화**: 복잡한 로직을 단순한 인터페이스로 감춤
- **재사용성**: 한 번 만든 컴포넌트를 여러 곳에서 활용

## React가 소프트웨어 개발에 미친 철학적 영향

### 함수형 프로그래밍의 대중화

React는 함수형 프로그래밍의 핵심 개념들을 웹 개발에 도입했습니다:

**순수 함수의 개념**
React 컴포넌트는 본질적으로 순수 함수입니다. 같은 props가 주어지면 항상 같은 결과를 반환해야 합니다.

**불변성의 중요성**
상태를 직접 변경하지 않고 새로운 상태를 생성하는 불변성 원칙을 강조했습니다.

**고차 함수의 활용**
컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 Higher-Order Component 패턴을 도입했습니다.

### 선언적 UI의 새로운 표준

React가 도입한 선언적 UI 패러다임은 이후 다른 프레임워크들에게도 영향을 미쳤습니다:

- Vue.js의 템플릿 시스템
- Angular의 새로운 방향성
- Flutter, SwiftUI 등 모바일 개발 패러다임
- React Native를 통한 크로스 플랫폼 개발

## 언제 React를 선택해야 할까?

### React의 철학이 적합한 상황

**복잡성이 증가하는 프로젝트**
프로젝트의 복잡성이 증가할수록 React의 장점이 더욱 부각됩니다. 상태 관리, 컴포넌트 재사용, 데이터 흐름 제어 등의 문제를 체계적으로 해결할 수 있습니다.

**장기적 유지보수가 중요한 경우**
React의 선언적 특성과 컴포넌트 기반 아키텍처는 코드의 가독성과 유지보수성을 크게 향상시킵니다.

**팀 개발과 협업이 중요한 환경**
컴포넌트의 독립성과 명확한 인터페이스는 여러 개발자가 동시에 작업하기에 이상적입니다.

### React가 과할 수 있는 상황

**단순한 정적 사이트**
상태 변화가 거의 없는 단순한 사이트에서는 React의 복잡성이 오히려 부담이 될 수 있습니다.

**즉시성이 중요한 프로토타입**
빠른 프로토타이핑이 필요한 상황에서는 React의 학습 곡선과 설정 과정이 부담이 될 수 있습니다.

**SEO가 절대적으로 중요한 경우**
클라이언트 사이드 렌더링의 한계로 인해 SEO에 불리할 수 있습니다. 하지만 Next.js 같은 프레임워크로 해결 가능합니다.

## 결론: React가 가져온 패러다임의 혁신

React는 단순한 라이브러리를 넘어서 웹 개발의 패러다임을 근본적으로 바꿨습니다.

**React의 핵심 철학:**

- **예측 가능성**: 상태와 UI의 관계가 명확함
- **조합성**: 작은 부품들을 조합하여 복잡한 시스템 구축
- **선언적 사고**: "어떻게"가 아닌 "무엇을"에 집중
- **함수형 접근**: 순수 함수와 불변성을 통한 안정성

이러한 철학적 변화는 개발자가 더 나은 소프트웨어를 만들 수 있게 도와주었고, 웹 개발을 단순한 "페이지 만들기"에서 "사용자 경험을 설계하는 것"으로 격상시켰습니다.

React를 사용한다는 것은 단순히 도구를 선택하는 것이 아니라, 더 나은 소프트웨어 개발 철학을 받아들이는 것입니다.
