---
sidebar_position: 4
---

# 생명주기 메서드 (Lifecycle Methods)

## 생명주기 개념의 철학적 기원

### 생물학적 은유에서 출발한 개념

**"생명체"로서의 컴포넌트**
React에서 컴포넌트를 "생명주기"라는 개념으로 설명하는 것은 우연이 아닙니다. 이는 컴포넌트를 하나의 살아있는 개체로 보는 철학적 관점에서 출발했습니다. 마치 생물이 태어나고, 성장하고, 죽는 것처럼, 컴포넌트도 생성(Birth) → 성장/변화(Growth) → 소멸(Death)의 과정을 거칩니다.

**시간의 흐름과 상태 변화**
생명주기는 본질적으로 "시간"의 개념을 프로그래밍에 도입한 것입니다. 프로그램은 정적인 것이 아니라, 시간에 따라 변화하는 동적인 시스템이라는 인식을 반영합니다.

### 브라우저 렌더링 엔진과의 조화

**DOM의 생명주기와 React 컴포넌트의 연관성**
브라우저에서 DOM 요소들도 생성 → 렌더링 → 제거의 과정을 거칩니다. React의 생명주기는 이러한 브라우저의 자연스러운 흐름과 조화를 이루도록 설계되었습니다.

**렌더링 파이프라인과의 동기화**
브라우저의 렌더링 과정(Parse → Style → Layout → Paint → Composite)과 React의 생명주기가 어떻게 맞물리는지 이해하는 것이 중요합니다.

## 생명주기가 해결하려 한 근본적 문제

### 메모리 관리와 리소스 정리

**가비지 컬렉션의 한계**
JavaScript의 가비지 컬렉션은 객체의 참조가 없어질 때 자동으로 메모리를 회수하지만, 이벤트 리스너, 타이머, 네트워크 요청 등은 명시적으로 정리해야 합니다. 생명주기는 이러한 "정리 작업"을 체계적으로 관리할 수 있는 방법을 제공합니다.

**메모리 누수 방지의 철학**
"생명주기"라는 개념을 통해 개발자에게 "시작한 것은 반드시 끝내야 한다"는 책임감을 심어주었습니다.

### 비동기 작업의 체계적 관리

**Promise와 생명주기의 관계**
컴포넌트가 언마운트된 후에도 Promise가 resolve되어 setState를 호출하는 문제를 해결하기 위한 패턴을 제공합니다.

**데이터 페칭의 적절한 시점**
언제 데이터를 가져와야 하고, 언제 정리해야 하는지에 대한 명확한 가이드라인을 제공합니다.

## 생명주기와 함수형 프로그래밍의 충돌과 해결

### 객체지향적 생명주기의 한계

**상태를 가진 객체의 복잡성**
전통적인 생명주기 메서드는 객체지향 프로그래밍의 관점에서 설계되었습니다. 컴포넌트는 상태를 가진 객체이고, 각 생명주기 단계에서 그 상태를 조작하는 방식이었습니다. 하지만 이는 다음과 같은 문제를 가져왔습니다:

- 관련 없는 로직들이 같은 생명주기 메서드에 섞임
- 관련 있는 로직들이 다른 생명주기 메서드에 분산됨
- 로직의 재사용이 어려움

**함수형 패러다임과의 불일치**
함수형 프로그래밍에서는 "순수 함수"와 "부작용 분리"를 중시합니다. 하지만 전통적인 생명주기 메서드는 이러한 원칙과 충돌했습니다.

### useEffect의 철학적 혁신

**"무엇을 언제"에서 "무엇이 무엇에 의존하는가"로의 전환**
기존의 생명주기는 "componentDidMount에서 이것을 하고, componentWillUnmount에서 저것을 한다"는 시간 기반 사고였습니다. useEffect는 "이 부작용은 이 값들에 의존한다"는 의존성 기반 사고로 전환했습니다.

**관심사의 분리 실현**
하나의 생명주기 메서드에 여러 관심사가 섞이는 대신, 각각의 useEffect가 하나의 관심사만 담당하게 되었습니다.

**선언적 정리(Cleanup)**
return 문을 통한 정리 함수는 "설정한 것을 해제한다"는 대칭성을 코드에서 직접 표현할 수 있게 했습니다.

## 브라우저 이벤트 루프와 생명주기의 상호작용

### React의 렌더링 스케줄링

**브라우저의 프레임 기반 렌더링**
브라우저는 일반적으로 60fps로 화면을 갱신합니다. 즉, 16.67ms마다 한 프레임을 렌더링합니다. React의 생명주기는 이러한 브라우저의 렌더링 주기와 조화를 이루도록 설계되었습니다.

**Concurrent Mode와 생명주기의 진화**
React 18의 Concurrent Mode는 생명주기의 개념을 더욱 발전시켰습니다. 렌더링을 중단하고 재시작할 수 있게 되면서, 전통적인 생명주기의 "한 번만 실행된다"는 가정이 깨졌습니다.

### 메모리 관리의 심층 원리

**참조 순환과 메모리 누수**
React 컴포넌트에서 가장 흔한 메모리 누수는 이벤트 리스너나 타이머가 컴포넌트를 참조하고 있는 상황입니다. 생명주기는 이러한 순환 참조를 끊을 수 있는 명확한 시점을 제공합니다.

**가비지 컬렉션과의 협력**
생명주기 메서드에서 수행하는 정리 작업은 가비지 컬렉터가 메모리를 회수할 수 있도록 도와줍니다. 이는 단순히 메모리를 해제하는 것이 아니라, 참조 관계를 정리하는 것입니다.

## 생명주기의 3단계와 그 철학적 의미

### 1. 마운팅(Mounting)

컴포넌트가 생성되어 DOM에 삽입되는 과정

### 2. 업데이트(Updating)

컴포넌트의 props나 state가 변경되어 다시 렌더링되는 과정

### 3. 언마운팅(Unmounting)

컴포넌트가 DOM에서 제거되는 과정

## 클래스형 컴포넌트의 생명주기 메서드

### 마운팅 단계 메서드

#### 1. constructor()

```jsx
constructor(props) {
  super(props);
  this.state = {
    count: 0
  };
}
```

**실행 시점**: 컴포넌트가 생성될 때 가장 먼저 실행
**주요 용도**:

- 초기 state 설정
- 이벤트 핸들러 바인딩
- 인스턴스 변수 초기화

**주의사항**:

- `super(props)` 반드시 호출
- 여기서 `setState()` 호출하면 안됨

#### 2. componentDidMount()

```jsx
componentDidMount() {
  // API 호출
  fetch('/api/data')
    .then(response => response.json())
    .then(data => this.setState({ data }));

  // DOM 조작
  this.inputRef.focus();

  // 이벤트 리스너 등록
  window.addEventListener('resize', this.handleResize);
}
```

**실행 시점**: 컴포넌트가 DOM에 삽입된 직후
**주요 용도**:

- API 호출
- DOM 직접 조작
- 외부 라이브러리 연동
- 이벤트 리스너 등록
- 타이머 설정

### 업데이트 단계 메서드

#### 1. componentDidUpdate()

```jsx
componentDidUpdate(prevProps, prevState, snapshot) {
  // props 변경 시 API 재호출
  if (prevProps.userId !== this.props.userId) {
    this.fetchUserData(this.props.userId);
  }

  // state 변경에 따른 추가 작업
  if (prevState.searchTerm !== this.state.searchTerm) {
    this.performSearch(this.state.searchTerm);
  }
}
```

**실행 시점**: 업데이트가 완료된 직후
**주요 용도**:

- props나 state 변경에 따른 추가 작업
- DOM 업데이트 후 작업
- 네트워크 요청

#### 2. shouldComponentUpdate()

```jsx
shouldComponentUpdate(nextProps, nextState) {
  // count가 변경될 때만 리렌더링
  return nextState.count !== this.state.count;
}
```

**실행 시점**: 렌더링 직전
**주요 용도**:

- 성능 최적화
- 불필요한 리렌더링 방지
  **반환값**: boolean (true: 렌더링 진행, false: 렌더링 중단)

#### 3. getSnapshotBeforeUpdate()

```jsx
getSnapshotBeforeUpdate(prevProps, prevState) {
  // 스크롤 위치 저장
  if (prevState.messages.length < this.state.messages.length) {
    const list = this.listRef.current;
    return list.scrollHeight - list.scrollTop;
  }
  return null;
}

componentDidUpdate(prevProps, prevState, snapshot) {
  // 저장된 스크롤 위치 복원
  if (snapshot !== null) {
    const list = this.listRef.current;
    list.scrollTop = list.scrollHeight - snapshot;
  }
}
```

**실행 시점**: DOM 업데이트 직전
**주요 용도**:

- DOM 업데이트 전 정보 캡처
- 스크롤 위치 보존
  **반환값**: snapshot 값 (componentDidUpdate의 세 번째 인자로 전달)

### 언마운팅 단계 메서드

#### componentWillUnmount()

```jsx
componentWillUnmount() {
  // 이벤트 리스너 제거
  window.removeEventListener('resize', this.handleResize);

  // 타이머 정리
  clearInterval(this.timer);

  // API 요청 취소
  this.abortController.abort();

  // 구독 해제
  this.subscription.unsubscribe();
}
```

**실행 시점**: 컴포넌트가 DOM에서 제거되기 직전
**주요 용도**:

- 메모리 누수 방지
- 이벤트 리스너 제거
- 타이머 정리
- API 요청 취소
- 구독 해제

## 에러 처리 메서드

### componentDidCatch()

```jsx
componentDidCatch(error, errorInfo) {
  console.error('컴포넌트 에러:', error, errorInfo);

  // 에러 로깅 서비스에 전송
  this.logErrorToService(error, errorInfo);
}
```

**실행 시점**: 자식 컴포넌트에서 에러 발생 시
**주요 용도**:

- 에러 로깅
- 에러 바운더리 구현

### static getDerivedStateFromError()

```jsx
static getDerivedStateFromError(error) {
  // 에러 발생 시 fallback UI를 위한 state 업데이트
  return { hasError: true };
}
```

**반환값**: state 업데이트 객체

## 함수형 컴포넌트에서의 생명주기

### useEffect Hook으로 생명주기 구현

#### componentDidMount 대체

```jsx
useEffect(() => {
  // 마운트 시 실행
  fetchData();
}, []); // 빈 배열 = 마운트 시에만 실행
```

#### componentDidUpdate 대체

```jsx
useEffect(() => {
  // props나 state 변경 시 실행
  updateData();
}, [dependency]); // 의존성 배열의 값이 변경될 때 실행
```

#### componentWillUnmount 대체

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    // 타이머 로직
  }, 1000);

  // cleanup 함수 (언마운트 시 실행)
  return () => {
    clearInterval(timer);
  };
}, []);
```

#### 복합적인 생명주기 관리

```jsx
useEffect(() => {
  // 마운트 시 + userId 변경 시 실행
  fetchUserData(userId);

  const subscription = subscribeToUser(userId);

  // cleanup (언마운트 시 + userId 변경되어 재실행되기 전)
  return () => {
    subscription.unsubscribe();
  };
}, [userId]);
```

## 생명주기 메서드 사용 시 주의사항

### 1. 메모리 누수 방지

```jsx
// 잘못된 예
componentDidMount() {
  setInterval(() => {
    this.setState({ time: new Date() });
  }, 1000);
}

// 올바른 예
componentDidMount() {
  this.timer = setInterval(() => {
    this.setState({ time: new Date() });
  }, 1000);
}

componentWillUnmount() {
  clearInterval(this.timer);
}
```

### 2. 무한 루프 방지

```jsx
// 잘못된 예 - 무한 루프 발생
componentDidUpdate() {
  this.setState({ count: this.state.count + 1 });
}

// 올바른 예
componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    // 조건부 state 업데이트
  }
}
```

### 3. 비동기 작업 처리

```jsx
componentDidMount() {
  this.mounted = true;

  fetch('/api/data')
    .then(response => response.json())
    .then(data => {
      // 컴포넌트가 언마운트되었는지 확인
      if (this.mounted) {
        this.setState({ data });
      }
    });
}

componentWillUnmount() {
  this.mounted = false;
}
```

## 성능 최적화와 생명주기

### PureComponent 사용

```jsx
class MyComponent extends React.PureComponent {
  // shouldComponentUpdate가 자동으로 얕은 비교 수행
  render() {
    return <div>{this.props.name}</div>;
  }
}
```

### React.memo (함수형 컴포넌트)

```jsx
const MyComponent = React.memo(function MyComponent({ name }) {
  return <div>{name}</div>;
});

// 커스텀 비교 함수
const MyComponent = React.memo(
  function MyComponent(props) {
    return <div>{props.name}</div>;
  },
  (prevProps, nextProps) => {
    return prevProps.name === nextProps.name;
  }
);
```

## 실제 사용 예시

### 데이터 페칭 컴포넌트

```jsx
class UserProfile extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      user: null,
      loading: true,
      error: null,
    };
  }

  async componentDidMount() {
    try {
      const user = await fetchUser(this.props.userId);
      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ error, loading: false });
    }
  }

  async componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      this.setState({ loading: true });
      try {
        const user = await fetchUser(this.props.userId);
        this.setState({ user, loading: false });
      } catch (error) {
        this.setState({ error, loading: false });
      }
    }
  }

  render() {
    const { user, loading, error } = this.state;

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    if (!user) return <div>User not found</div>;

    return <div>Welcome, {user.name}!</div>;
  }
}
```

## 현재 권장사항

### React 팀의 권장사항

1. **새로운 코드**: 함수형 컴포넌트 + useEffect 사용
2. **기존 클래스형 컴포넌트**: 점진적 마이그레이션
3. **에러 바운더리**: 여전히 클래스형 컴포넌트 필요

### 마이그레이션 가이드

```jsx
// Before (Class)
class Timer extends React.Component {
  componentDidMount() {
    this.timer = setInterval(() => {
      this.setState({ time: new Date() });
    }, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }
}

// After (Function)
function Timer() {
  useEffect(() => {
    const timer = setInterval(() => {
      setTime(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);
}
```

## 결론

생명주기 메서드는 React 컴포넌트의 동작을 제어하는 핵심 개념입니다. 클래스형 컴포넌트에서는 명시적인 생명주기 메서드를, 함수형 컴포넌트에서는 useEffect Hook을 사용하여 같은 기능을 구현할 수 있습니다.

면접에서는 각 생명주기 메서드의 실행 시점과 용도, 그리고 함수형 컴포넌트에서 useEffect로 어떻게 대체하는지 설명할 수 있어야 합니다. 특히 메모리 누수 방지와 성능 최적화 관점에서의 이해가 중요합니다.
