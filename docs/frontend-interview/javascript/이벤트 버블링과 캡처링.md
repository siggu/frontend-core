---
sidebar_position: 4
---

# 이벤트 버블링과 캡처링

HTML 요소들은 계층적으로 구조화되어 있기 때문에, 중첩된 요소에서 이벤트가 발생하면 부모 요소들에서도 이벤트가 트리거될 수 있다. 이러한 이벤트 전파 방식을 이해하는 것은 JavaScript 개발에서 매우 중요하다.

## 이벤트 전파란?

**이벤트 전파**(**Event Propagation**)는 DOM 요소에서 이벤트가 발생했을 때, 그 이벤트가 DOM 트리를 따라 전달되는 과정을 말한다.

### 기본 HTML 구조 예시

```html
<form onclick="alert('form')">
  FORM
  <div onclick="alert('div')">
    DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

위 구조에서 `<p>` 요소를 클릭하면, 다음과 같은 순서로 alert가 발생한다:

1. "p" → 2. "div" → 3. "form"

이는 **버블링(Bubbling)** 방식으로, 자식 요소에서 부모 요소로 이벤트가 전파되는 것이다.

<br></br>

## 이벤트 전파의 3단계

표준 DOM 이벤트 플로우에는 3가지 단계가 있다:

### 1. 캡처링 단계 (Capturing Phase)

이벤트가 **최상위 요소에서 타겟까지 내려가는** 단계

### 2. 타겟 단계 (Target Phase)

이벤트가 **실제 타겟 요소에 도달하는** 단계

### 3. 버블링 단계 (Bubbling Phase)

이벤트가 **타겟에서 최상위 요소까지 올라가는** 단계

```javascript
// 이벤트 전파 순서 확인
document.getElementById('ancestor').addEventListener('click', (e) => {
  console.log('ancestor clicked');
});

document.getElementById('parent').addEventListener('click', (e) => {
  console.log('parent clicked');
});

document.getElementById('child').addEventListener('click', (e) => {
  console.log('child clicked');
});

// child 클릭 시 출력 순서:
// child clicked
// parent clicked
// ancestor clicked
```

<br></br>

## 이벤트 전파가 존재하는 이유

### 1. 논리적 관점

- 자식 요소는 부모 요소 안에 포함되어 있다
- 자식 요소를 클릭하는 것은 부모 요소도 부분적으로 클릭하는 것으로 볼 수 있다

### 2. 성능 최적화

- 모든 개별 요소에 이벤트 리스너를 등록할 필요가 없다
- **이벤트 위임(Event Delegation)** 기법을 가능하게 한다

<br></br>

## 버블링 (Bubbling)

### 기본 동작

대부분의 이벤트는 기본적으로 **버블링**된다. 즉, 이벤트 리스너가 가장 안쪽 요소부터 바깥쪽으로 트리거된다.

```javascript
// HTML: <div id="outer"><div id="inner">클릭</div></div>

document.getElementById('outer').addEventListener('click', (e) => {
  console.log('outer div clicked');
});

document.getElementById('inner').addEventListener('click', (e) => {
  console.log('inner div clicked');
});

// inner div 클릭 시:
// "inner div clicked"
// "outer div clicked"
```

### 이벤트 위임을 통한 활용

```javascript
// 부모 요소에 하나의 리스너만 등록
document.getElementById('todo-list').addEventListener('click', function (e) {
  // 삭제 버튼 클릭
  if (e.target.classList.contains('delete-btn')) {
    e.target.closest('.todo-item').remove();
  }

  // 체크박스 클릭
  if (e.target.classList.contains('complete-checkbox')) {
    e.target.closest('.todo-item').classList.toggle('completed');
  }
});

// 동적으로 추가되는 할 일 아이템도 자동으로 이벤트 처리됨
function addTodoItem(text) {
  const todoList = document.getElementById('todo-list');
  todoList.innerHTML += `
    <div class="todo-item">
      <input type="checkbox" class="complete-checkbox">
      <span>${text}</span>
      <button class="delete-btn">삭제</button>
    </div>
  `;
}
```

<br></br>

## 캡처링 (Capturing)

### 캡처링 등록

`addEventListener()`의 세 번째 매개변수에 `true`를 전달하면 캡처링 단계에서 이벤트를 처리한다:

```javascript
element.addEventListener('click', handler, true); // 캡처링
element.addEventListener('click', handler, false); // 버블링 (기본값)
```

### 캡처링 플로우

```javascript
// HTML: <div id="outer"><div id="inner">클릭</div></div>

// 캡처링 단계 리스너
document.getElementById('outer').addEventListener(
  'click',
  (e) => {
    console.log('outer capturing');
  },
  true
);

document.getElementById('inner').addEventListener(
  'click',
  (e) => {
    console.log('inner capturing');
  },
  true
);

// 버블링 단계 리스너
document.getElementById('outer').addEventListener('click', (e) => {
  console.log('outer bubbling');
});

document.getElementById('inner').addEventListener('click', (e) => {
  console.log('inner bubbling');
});

// inner 클릭 시 출력 순서:
// "outer capturing"
// "inner capturing"
// "inner bubbling"
// "outer bubbling"
```

### 캡처링 활용 사례

**전역 이벤트 가로채기:**

```javascript
// 모든 클릭을 캡처링 단계에서 로깅
document.addEventListener(
  'click',
  function (e) {
    console.log(`클릭된 요소: ${e.target.tagName}`);
    console.log(`시간: ${new Date().toLocaleTimeString()}`);
  },
  true
);

// 비활성화된 요소 클릭 차단
document.addEventListener(
  'click',
  function (e) {
    if (e.target.classList.contains('disabled')) {
      console.log('비활성화된 요소 클릭 차단');
      e.stopPropagation();
      e.preventDefault();
    }
  },
  true
);
```

<br></br>

## 이벤트 전파 제어

### event.stopPropagation()

**이벤트의 추가 전파를 중단**한다:

```javascript
document.getElementById('child').addEventListener('click', function (e) {
  console.log('자식 클릭됨');
  e.stopPropagation(); // 여기서 전파 중단
});

document.getElementById('parent').addEventListener('click', function (e) {
  console.log('부모 클릭됨'); // 실행되지 않음
});
```

### event.stopImmediatePropagation()

**같은 요소의 다른 리스너들도 포함하여 모든 전파를 즉시 중단**한다:

```javascript
const button = document.getElementById('btn');

// 첫 번째 리스너
button.addEventListener('click', function (e) {
  console.log('첫 번째 리스너');
  e.stopImmediatePropagation(); // 모든 전파 중단
});

// 두 번째 리스너 (실행되지 않음)
button.addEventListener('click', function (e) {
  console.log('두 번째 리스너');
});
```

### event.preventDefault()

**브라우저의 기본 동작을 취소**한다 (전파는 계속됨):

```javascript
// 링크 클릭 시 페이지 이동 방지
document.querySelectorAll('a').forEach((link) => {
  link.addEventListener('click', function (e) {
    e.preventDefault(); // 페이지 이동 방지
    console.log('링크 클릭됨, 하지만 이동 안함');

    // 커스텀 동작 수행
    showModal(this.href);
  });
});

// 폼 제출 방지
document.getElementById('form').addEventListener('submit', function (e) {
  e.preventDefault(); // 폼 제출 방지

  // AJAX로 데이터 전송
  submitFormViaAjax(this);
});
```

### 메서드 비교표

| 메서드                       | 전파 중단 | 기본 동작 취소 | 같은 요소 다른 리스너 |
| ---------------------------- | --------- | -------------- | --------------------- |
| `stopPropagation()`          | ✅        | ❌             | 실행됨                |
| `preventDefault()`           | ❌        | ✅             | 실행됨                |
| `stopImmediatePropagation()` | ✅        | ❌             | 중단됨                |

<br></br>

## 실제 개발 활용 사례

### 모달 창 외부 클릭으로 닫기

```javascript
function openModal() {
  const modal = document.getElementById('modal');
  const modalContent = document.querySelector('.modal-content');

  modal.style.display = 'block';

  // 모달 배경 클릭 시 닫기
  modal.addEventListener('click', function (e) {
    if (e.target === modal) {
      closeModal();
    }
  });

  // 모달 내용 클릭 시 닫기 방지
  modalContent.addEventListener('click', function (e) {
    e.stopPropagation();
  });
}
```

### 드롭다운 메뉴

```javascript
class Dropdown {
  constructor(trigger, menu) {
    this.trigger = document.querySelector(trigger);
    this.menu = document.querySelector(menu);
    this.isOpen = false;

    this.init();
  }

  init() {
    // 트리거 클릭으로 메뉴 토글
    this.trigger.addEventListener('click', (e) => {
      e.stopPropagation();
      this.toggle();
    });

    // 메뉴 내부 클릭 시 닫기 방지
    this.menu.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // 외부 클릭 시 메뉴 닫기
    document.addEventListener('click', () => {
      if (this.isOpen) {
        this.close();
      }
    });
  }

  toggle() {
    this.isOpen ? this.close() : this.open();
  }

  open() {
    this.menu.classList.add('active');
    this.isOpen = true;
  }

  close() {
    this.menu.classList.remove('active');
    this.isOpen = false;
  }
}
```

### 동적 테이블 관리

```javascript
// 테이블 전체에 하나의 리스너만 등록
document.getElementById('user-table').addEventListener('click', function (e) {
  const row = e.target.closest('tr');
  if (!row) return;

  // 행 선택
  document.querySelectorAll('tr.selected').forEach((tr) => {
    tr.classList.remove('selected');
  });
  row.classList.add('selected');

  // 삭제 버튼 클릭
  if (e.target.classList.contains('delete-btn')) {
    if (confirm('정말 삭제하시겠습니까?')) {
      row.remove();
    }
  }

  // 편집 버튼 클릭
  if (e.target.classList.contains('edit-btn')) {
    const userId = row.dataset.userId;
    openEditModal(userId);
  }
});
```

<br></br>

## 주의사항과 모범 사례

### 과도한 이벤트 중단 방지

event.stopPropagation()을 남용하면 다른 개발자가 작성한 코드나 라이브러리의 동작을 방해할 수 있다.

```javascript
// ❌ 좋지 않은 예: 모든 클릭 이벤트 차단
document.querySelector('.button').addEventListener('click', function (e) {
  e.stopPropagation(); // 다른 기능을 방해할 수 있음
  // 버튼 기능 수행
});

// ✅ 좋은 예: 필요한 경우에만 선택적으로 차단
document.querySelector('.modal-close').addEventListener('click', function (e) {
  e.preventDefault(); // 링크 기본 동작만 방지
  closeModal();
});
```

### 이벤트 위임 활용

동적으로 생성되는 요소가 많은 경우 이벤트 위임을 적극 활용하자:

```javascript
// ❌ 비효율적: 각각에 리스너 등록
document.querySelectorAll('.item').forEach((item) => {
  item.addEventListener('click', handleClick);
});

// ✅ 효율적: 부모에 하나의 리스너
document.getElementById('container').addEventListener('click', function (e) {
  if (e.target.classList.contains('item')) {
    handleClick(e);
  }
});
```

<br></br>

## 버블링되지 않는 이벤트들

일부 이벤트는 **버블링되지 않는다**:

```javascript
// 버블링되지 않는 이벤트들
const nonBubblingEvents = ['focus', 'blur', 'load', 'unload', 'scroll', 'resize', 'mouseenter', 'mouseleave'];

// 이런 이벤트들을 부모에서 감지하려면 캡처링 사용
document.addEventListener(
  'focus',
  function (e) {
    console.log('포커스 이벤트:', e.target);
  },
  true
); // 캡처링으로 등록

// 또는 버블링되는 대체 이벤트 사용
document.addEventListener('focusin', function (e) {
  console.log('포커스 이벤트:', e.target);
}); // focusin은 버블링됨
```

<br></br>

## 자주 묻는 질문 (FAQ)

### Q: addEventListener의 세 번째 매개변수는 무엇인가요?

**세 번째 매개변수는 캡처링 여부나 옵션 객체를 설정합니다:**

```javascript
// 불린값: 캡처링 여부
element.addEventListener('click', handler, true); // 캡처링
element.addEventListener('click', handler, false); // 버블링 (기본값)

// 객체: 세부 옵션 설정
element.addEventListener('click', handler, {
  capture: true, // 캡처링 사용
  once: true, // 한 번만 실행 후 자동 제거
  passive: true, // preventDefault() 호출하지 않음을 보장
  signal: abortSignal, // AbortController로 제거 가능
});
```

### Q: 이벤트 위임 시 성능상 이점이 정말 있나요?

**예, 특히 동적 요소가 많을 때 큰 이점이 있습니다:**

```javascript
// 성능 테스트 시나리오
function createManyButtons() {
  const container = document.getElementById('container');

  // 1000개 버튼 생성
  for (let i = 0; i < 1000; i++) {
    const button = document.createElement('button');
    button.textContent = `버튼 ${i}`;
    button.className = 'dynamic-btn';
    container.appendChild(button);
  }
}

// ❌ 각 버튼에 개별 리스너 (1000개 리스너)
function addIndividualListeners() {
  document.querySelectorAll('.dynamic-btn').forEach((btn) => {
    btn.addEventListener('click', function () {
      console.log('버튼 클릭:', this.textContent);
    });
  });
}

// ✅ 이벤트 위임 (1개 리스너)
function addDelegatedListener() {
  document.getElementById('container').addEventListener('click', function (e) {
    if (e.target.classList.contains('dynamic-btn')) {
      console.log('버튼 클릭:', e.target.textContent);
    }
  });
}

// 메모리 사용량과 이벤트 등록 시간이 현저히 차이남
```

### Q: preventDefault()와 stopPropagation()을 함께 사용해야 하는 경우는?

**링크나 폼에서 기본 동작과 전파를 모두 막고 싶을 때:**

```javascript
// 커스텀 링크 동작
document.querySelectorAll('a.custom-link').forEach((link) => {
  link.addEventListener('click', function (e) {
    e.preventDefault(); // 페이지 이동 방지
    e.stopPropagation(); // 부모 클릭 이벤트 방지

    // 커스텀 동작 수행
    handleCustomLinkClick(this.href);
  });
});

// 중첩된 클릭 가능 요소
// <div class="card" onclick="selectCard()">
//   <button class="delete-btn" onclick="deleteCard()">삭제</button>
// </div>
document.querySelectorAll('.delete-btn').forEach((btn) => {
  btn.addEventListener('click', function (e) {
    e.stopPropagation(); // 카드 선택 이벤트 방지

    // 삭제 로직만 실행
    deleteCard(this.closest('.card'));
  });
});
```

### Q: 모바일에서 터치 이벤트도 버블링되나요?

**네, 터치 이벤트도 동일하게 버블링됩니다:**

```javascript
// 터치 이벤트도 버블링 적용
document.getElementById('parent').addEventListener('touchstart', function (e) {
  console.log('부모 터치 시작');
});

document.getElementById('child').addEventListener('touchstart', function (e) {
  console.log('자식 터치 시작');
  e.stopPropagation(); // 터치 이벤트 전파도 중단 가능
});

// 터치와 마우스 이벤트 통합 처리
function addUnifiedListener(element, handler) {
  // 터치 디바이스에서는 터치 이벤트를, 그 외에는 마우스 이벤트를
  if ('ontouchstart' in window) {
    element.addEventListener('touchstart', handler);
  } else {
    element.addEventListener('click', handler);
  }
}
```

### Q: React나 Vue에서도 이벤트 버블링이 동일하게 작용하나요?

**기본적으로는 동일하지만, 프레임워크별 특성이 있습니다:**

```javascript
// React - SyntheticEvent 사용
function MyComponent() {
  const handleClick = (e) => {
    e.stopPropagation(); // React SyntheticEvent
    console.log('버튼 클릭');
  };

  return (
    <div onClick={() => console.log('div 클릭')}>
      <button onClick={handleClick}>클릭</button>
    </div>
  );
}

// Vue - 네이티브 이벤트와 동일
// <template>
//   <div @click="handleDivClick">
//     <button @click.stop="handleButtonClick">클릭</button>
//   </div>
// </template>

// Vue의 이벤트 수식어
// @click.stop="handler"        - stopPropagation()
// @click.prevent="handler"     - preventDefault()
// @click.capture="handler"     - 캡처링 모드
// @click.once="handler"        - 한 번만 실행
```

### Q: 커스텀 이벤트도 버블링되나요?

**네, 커스텀 이벤트도 버블링 설정이 가능합니다:**

```javascript
// 커스텀 이벤트 생성 및 디스패치
function dispatchCustomEvent(element, eventName, data) {
  const customEvent = new CustomEvent(eventName, {
    detail: data,
    bubbles: true, // 버블링 허용
    cancelable: true, // 취소 가능
  });

  element.dispatchEvent(customEvent);
}

// 커스텀 이벤트 리스너
document.getElementById('child').addEventListener('customEvent', function (e) {
  console.log('자식에서 커스텀 이벤트:', e.detail);
  e.stopPropagation(); // 커스텀 이벤트도 전파 제어 가능
});

document.getElementById('parent').addEventListener('customEvent', function (e) {
  console.log('부모에서 커스텀 이벤트:', e.detail);
});

// 사용
dispatchCustomEvent(document.getElementById('child'), 'customEvent', { message: '안녕하세요!' });
```

이벤트 버블링과 캡처링을 잘 이해하면 DOM 이벤트를 더 효율적이고 우아하게 처리할 수 있으며, 복잡한 UI 상호작용도 깔끔하게 구현할 수 있습니다.
