---
sidebar_position: 1
---

# 브라우저 렌더링 과정

주소창에 `www.google.com`을 치고 Enter를 눌렀을 때 아래 그림처럼 총 3단계로 구분할 수 있다.

![브라우저 렌더링 과정](./svg/브라우저%20렌더링%20과정.svg)

## 브라우저 렌더링 과정

### 1. 주소창에 입력한 텍스트 정보 확인

- 대부분의 인터넷 브라우저는 자사의 주소창과 검색창을 동일하게 사용하고 있다.(대표적으로 Chrome은 주소창을 구굴의 검색창으로 쓰고 있다.)
- 이럴 경우 브라우저는 사용자가 주소창에 어떤 텍스트를 입력했을 때, 이 텍스트가 검색어인지 URL인지 우선적으로 확인한다.(이 작업의 주체는 브라우저 엔진의 UI 스레드이다.)

1.  입력한 텍스트가 검색어라면,

    -> 브라우저는 검색 엔진의 URL에 검색어를 포함한 주소로 페이지를 이동시킨다.

2.  입력한 텍스트가 URL이면,

    -> 브라우저 엔진에서 (네트워크 스레드를 통해)네트워크 호출을 수행한다.

- 따라서, 주소창에 `www.google.com`을 입력한 경우 브라우저는 네트워크 호출을 수행하게 된다.

<br></br>

### 2. 네트워크 호출

- 먼저 브라우저가 왜 네트워크 호출을 수행해야 하는가?

  - 브라우저가 사용자에게 '구글'이라는 사이트를 화면에 보여주기 위해서 구글의 HTMl, CSS, 스크립트, 이미지 등의 데이터를 미리 가지고 있어야 한다. 하지만 현재 브라우저는 이러한 정보가 없고, 이러한 데이터들은 구글 서버 컴퓨터에 있다.
  - 때문에 브라우저는 구글 서버와의 네트워크 통신을 통해 이러한 데이터를 가져와야 한다. 따라서 '네트워크 호출' 과정은 크게 아래의 두 가지 과정으로 나누어 볼 수 있다.

1. 구글 서버의 주소를 알기 위해 네임 서버(`Name Server`)와 통신하기

2. 알아낸 주소를 바탕으로 구글 서버와 통신하여 필요한 데이터 응답받기

#### 1. 구글 서버의 주소를 찾는 과정

- 구글 서버의 주소를 알아내기 위해 **클라이언트**(사용자의 컴퓨터)는 다음 과정을 수행한다.

  1. 자신의 host 파일에서 **도메인 네임**(`google.com`)에 대응하는 IP 주소가 있는지 우선적으로 확인한다.

  2. 만일 없다면, 네임 서버(`Name Server`)에 '구글의 IP 주소를 알려주세요.'라는 요청을 보낸다.

- 인터넷은 컴퓨터의 주소인 IP 주소를 기반으로 동작한다. 하지만 우리가 인터넷을 사용할 땐, IP 주소 대신 사용하기 쉽도록 문자로 이루어진 도메인 네임을 사용한다.

- 따라서 도메인 네임을 IP 주소로 변환해 주는 환경인 **DNS**(**`Domain Name Server`**)가 반드시 필요한데, 이 DNS를 운영하는 장치를 **네임 서버**(**`Name Server`**) 혹은 DNS 서버라 한다.

#### 2. 구글 서버와 통신하여 필요한 데이터를 받는 과정 [^1]

- 이제 클라이언트는 구글 서버의 IP 주소를 알게 되어 구글 서버와 통신할 수 있게 되었다. 클라이언트의 브라우저는 (TCP 소켓을 열고 이를 통해) 구글 서버에 데이터를 요청하는 `HTTP Request`를 보낸다.

- `HTTP Request`를 받은 구글 서버는 클라이언트가 요청한 문서를 찾아 읽고 이를 바이트 형태로 변환한 후, 클라이언트로 **`HTTP Reply`**(**`HTTP Response`**)를 보낸다.

![서버와 통신하여 필요한 데이터를 받는 과정](./svg/서버와%20통신하여%20필요한%20데이터를%20받는%20과정.svg)

### 3. 렌더링 작업

- 브라우저 엔진(의 네트워크 스레드)은 네이버 서버로부터 응답받은 데이터에 악성 바이러스가 있는지 우선 검사한다. 이 데이터는 바이트 형태의 텍스트 문서이므로, 브라우저 엔진이 읽을 수 없다. 따라서 브라우저 엔진(의 UI 스레드)은 **렌더링 엔진**에게 해당 데이터를 해석하고, 웹 페이지를 화면에 띄울 것을 요청한다.

- 요청을 받은 렌더링 엔진은 받은 데이터를 바탕으로 **렌더링 프로세스**를 수행하고, 이 과정이 끝나면 브라우저 엔진에게 작업 완료를 알린다.

<br></br>

## 렌더링 프로세스

- 렌더링 엔진은 브라우저 엔진으로부터 요청받은 내용을 화면에 표시해주는 역할을 한다.

![렌더링 프로세스](./svg/렌더링%20프로세스.svg)

- 렌더링 과정은 아래 4가지 과정으로 이루어진다.

  1. HTML을 파싱하여 **DOM 트리 구축**, CSS를 파싱하여 **CSSOM 트리 구출** (+ JS 파싱)

  2. DOM 트리와 CSSOM 트리를 통해 렌더 트리 구축

  3. 렌더 트리 **배치**(Layout, Reflow)

  4. 렌더 트리 **그리기**(Paint)

### 파싱이란?

렌더링 프로세스를 이해하기 전에 파싱에 대해 이해해야 한다.

- 브라우저는 HTML, CSS 등 단순한 텍스트 문서를 이해하지 못한다. 따라서 이 문서를 브라우저가 이해할 수 있는 구조로 변화해주는 과정이 반드시 피요하다. 이를 **파싱**(**Parsing**)이라 한다.

- 파싱은 '어휘 분석'과 '구문 분석' 두 가지 과정으로 구분할 수 있다.

  1. **어휘 분석**: 문자열을 의미있는 작은 단위인 **토큰**(**token**)으로 분해하는 과정

  2. **구문 분석**: 문자열의 문법에 따라 토큰 간의 위계관계를 분석하여 **Parsing 트리**를 생성하는 과정

     :::note 파싱 예시
     HTML 문서 `<div>Hello World</div>`를 파싱하는 과정:

     1. **어휘 분석**: `<div>`, `Hello World`, `</div>` 토큰으로 + 분해
     2. **구문 분석**: div 태그 안에 텍스트가 있는 구조로 + 분석하여 트리 생성
        :::
        :::note 파싱 결과 생성되는 트리 형태를 parse 트리, parsing 트리, concrete syntax 트리 등 다양한 용어로 불린다.
        :::
        :::note parse 트리는 토큰화된 문자열의 단순한 트리에 불과하므로, 이를 바로 사용할 순 없다. 따라서 브라우저는 이 parse 트리를 DOM 트리로 바꾸어 사용한다.
        :::

#### 1.1 HTML 파싱 -> DOM 트리 파싱

- 렌더링 엔진이 HTML 문서를 수신받으면, HTML 파서는 이를 위에서부터 읽어 내려가며 파싱을 진행하고, 그 결과물로 **DOM 트리를 생성**한다.

  - **HTML 파싱 과정**

    1. 서버에서 바이트 형태의 HTML 문서를 응답받는다.
    2. 저장된 인코딩 방식(UTF-8)에 따라 이를 문자열로 변환한다.
    3. 변환된 문자열을 토큰으로 분해한다.
    4. 토큰을 내용에 따라 객체(노드)로 변환한다.
    5. 객체를 트리 구조로 구성하여 DOM을 생성한다.

  - 사용자의 만족도를 높이기 위해[^2] 렌더링 엔진은 HTML 문서가 모두 파싱될 때까지 기다리지 않고 파싱 이후의 과정인 배치와 그리기를 미리 진행한다.

#### 1.2 CSS 파싱 -> CSSOM 트리 생성

- HTML 파싱 중 CSS 문서를 가져오는 `link` 태그를 만나면, DOM 생성이 잠시 중단되고 해당 CSS의 파싱 과정이 시작된다.

- CSS 파서는 서버에서 받은 CSS 문서를 파싱하여 **CSSOM 트리**를 생성한다. CSS 파싱 과정은 기본적으로 [HTML 파싱 과정](#11-html-파싱---dom-트리-파싱)과 동일하다.

- CSSOM 트리의 노드는 DOM 트리 요소의 선택자에 맞춰 적용될 CSS 스타일 정보가 포함되어 있다.

#### 1.3 `JavaScript` 파싱[^3]

- HTML 파싱 중 `script` 태그를 만나면, 렌더링 엔진은 DOM 생성을 **잠시 중단**하고 서버에서 해당 `JavaScript` 리소스를 브라우저가 받아온다. 그리고 **`JavaScript`는 엔진에게 제어권을 넘겨준다.**

- `JavaScript` 엔진은 받아온 JS 리소스를 파싱하여 **AST**(**추상 구문 트리**)를 생성하고 이를 바이트 코드로 변환해 실행한다.

- `JavaScript` 파싱이 종료되면 렌더링 엔진은 다시 제어권을 돌려받고 DOM 생성을 이어나간다.

- 만약 `script` 태그를 `body` 태그의 중간에 작성할 경우, HTML 파싱이 끝나지 않은 상태에서 `JavaScript`로 인해 DOM이 조작되어 에러가 발생할 위험이 생긴다. 따라서 **`script` 태그는 반드시 `body` 태그 내부의 최하단에 위치해야 한다.**(혹은 `script` 태그에 `defer` 속성을 부여하는 방법도 있다.)

<br></br>

[^1]: 서버와 통신하여 필요한 데이터를 받는 과정

    - 클라이언트는 구글 서버의 IP 주소를 알게 되어 데이터를 요청하는 `HTTP Request`를 보낸다.

    - 해당 `HTTP Request` 메세지는 **TCP/IP 프로토콜**을 사용하여 서버로 전송된다.

      :::note TCP/IP 4계층
      인터넷에서 컴퓨터들이 데이터를 주고 받는데 사용되는 프로토콜(OSI 7계층 대신 실질적으로 쓰이는 프로토콜)
      ![TCP/IP 4계층](./svg/TCP%20IP%204계층.svg)
      :::

    - TCP는 전송 제어 프로토콜로 데이터의 전송을 제어하고 데이터를 어떻게 보낼지, 어떻게 맞출지 정한다.

    - IP의 특징인 비신뢰성과 비연결성으로 인해 IP 프로토콜만으로는 통신을 책임질 수 없다. 따라서 신뢰성과 연결성을 책임지는 TCP를 활용해 통신을 한다.

      :::note IP의 특징

      - 비신뢰성: 패킷이 실제로 도착했는지 확인 x, 패킷이 손실되어도 재전송 x, 패킷이 중복되거나 손상되어도 처리 x
      - 비연결성: 사전에 연결 x, 순서 보장 x, 각 패킷을 독립적으로 처리
        :::
        :::note TCP의 특징
      - 신뢰성: 데이터가 도착했는지 확인(ACK), 패킷 손실시 자동으로 재전송, 패킷에 순서 번호를 부여하여 올바른 순서로 재조립, 체크섬으로 데이터 무결성 확인
      - 연결성: 3-way handshake, 연결 상태를 지속적으로 추적, 수신자가 처리할 수 있는 속도에 맞춰 전송, 네트워크 상황에 따른 전송 속도 조절
        :::

    - TCP는 3-way handshake 과정을 통해 연결 및 데이터를 수신받고, 4-way handshake 과정을 통해 연결을 종료한다.

    - 3-way handshake의 과정

      ![3-way handshake의 과정](./svg/3-way%20handshake.svg)

    - 4-way handshake의 과정
      ![4-way handshake의 과정](./svg/4-way%20handshake.svg)

[^2]:
    HTML 파싱 과정에서, 렌더링 엔진은 사용자의 만족도를 높이기 위해 HTML 문서가 모두 파싱될 때까지 기다리지 않고 파싱 이후의 과정인 배치와 그리기를 진행한다.(이를 점진적 렌더링이라 함) 그렇다면 언제 수행하는가?

    - HTML 파싱 과정은 다음과 같다.

      바이트 -> 문자열 -> 토큰 -> 노드 -> DOM 트리

    - 점진적 렌더링이 일어나는 시점은 다음과 같다.

      | 진행 과정                | 렌더링 시점                 |
      | ------------------------ | --------------------------- |
      | 1. 바이트 수신(8KB 청크) |                             |
      | 2. UTF-8 문자열 변환     |                             |
      | 3. 토큰 분해             |                             |
      | 4. 노드 변환             |                             |
      | 5. DOM 트리 구성         | 부분 DOM 완성시 즉시 렌더링 |

      - 각 청크(8KB)마다 1~5 단계를 독립적으로 진행한다.

        :::note
        1차 렌더링: `<head>` 부분

        2차 렌더링: `<h1>` 요소 추가

        3차 렌더링: `<p>` 요소 추가
        ...
        :::

[^3]: `JavaScript` 파싱 과정(세부화)

    1단계: HTML 파싱 중 `<script>` 태그 발견

    - 2가지 경우로 분기

      - CASE 1: 외부 스크립트

        ```html
        <script src="app.js"></script>
        ```

        - 렌더링 엔진이 DOM 생성 중단

        - 네트워크 모듈이 서버에서 `JavaScript` 파일 다운로드

        - 파서 상태를 힙 메모리에 저장

      - CASE 2: 인라인 스크립트

        ```html
        <script>
          console.log('Hello World');
        </script>
        ```

        - 렌더링 엔진이 DOM 생성 중단

        - 네트워크 요청 없이 바로 `JavaScript` 코드 추출

        - 파서 상태를 힙 메모리에 저장

    2단계: `JavaScript` 엔진 제어권 이양 및 파싱

    - 2.1 토큰화(Tokenization)

      ```js
      function add(a, b) {
        return a + b;
      }
      ```

      ```
      [FUNCTION, IDENTIFIER(add), LPAREN, IDENTIFIER(a), COMMA, IDENTIFIER(b), RPAREN, LBRACE, RETURN, IDENTIFIER(a), PLUS, IDENTIFIER(b), SEMICOLON, RBRACE]
      ```

    - 2.2 AST(추상 구문 트리) 생성

      ```
      Program (루트 노드)
      └── FunctionDeclaration
          ├── Identifier: "add" (함수명)
          ├── Parameters [] (매개변수 배열)
          │   ├── Identifier: "a"
          │   └── Identifier: "b"
          └── BlockStatement (함수 본문)
              └── ReturnStatement
                  └── BinaryExpression
                      ├── Left: Identifier("a")
                      ├── Operator: "+"
                      └── Right: Identifier("b")
      ```

    - 2.3 바이트 코드 생성(컴파일)

      ```
      AST → 바이트코드 변환
      FunctionDeclaration → [FUNCTION_START, "add", 2]  // 함수 시작, 이름, 매개변수 개수
      BinaryExpression    → [LOAD_VAR, "a", LOAD_VAR, "b", ADD]  // 변수 로드, 덧셈
      ReturnStatement     → [RETURN]  // 반환
                          → [FUNCTION_END]  // 함수 끝
      ```

    3단계: `JavaScript` 실행

    - 실행 중 메모리 변화

      ```
      실행 컨텍스트 스택
      ┌─────────────────────────────────┐
      │ Global Execution Context        │
      │ ├─ Variable Environment         │
      │ ├─ Lexical Environment          │
      │ └─ This Binding                 │
      ├─ Function Execution Context     │  ← 함수 호출 시 추가
      │ ├─ Variable Environment         │
      │ ├─ Lexical Environment          │
      │ └─ This Binding                 │
      └─────────────────────────────────┘
      ```

    - DOM 조작 가능

      ```js
      // JavaScript 실행 중 DOM 접근 가능
      document.getElementById('myDiv').innerHTML = 'Hello';
      ```

      - 기존에 생성된 **DOM 객체들에 접근**

      - **새로운 DOM 노드 추가/수정** 가능

      - **즉시 화면에 반영** (리렌더링 발생)

    4단계: 제어권 복원 및 HTML 파싱 재개

    - `JavaScript` 실행 완료 후 정리

      ```
      메모리 정리 과정
      ┌───────────────────────────────────────┐
      │ JavaScript 메모리:                    │
      │ ├─ AST 노드들      → 가비지 컬렉션     │
      │ ├─ 바이트코드      → 캐시 저장         │
      │ ├─ 실행 컨텍스트   → 스택에서 제거     │
      │ └─ 전역 변수들     → 메모리 유지       │
      └───────────────────────────────────────┘
      ```
