---
sidebar_position: 3
---

# 프로세스와 스레드의 차이점

운영체제에서 실행의 기본 단위인 프로세스와 스레드는 프로그램 구조와 성능을 이해하는 데 필수적인 개념이다. 두 개념의 차이점을 명확히 알아야 효율적인 시스템 설계와 성능 최적화가 가능하다.

## 실행 단위란?

실행 단위는 운영체제가 "**어떻게 작업을 관리하고 실행할지**"를 결정하는 기본 개념이다.

### 실행 단위의 분류

실행 단위는 크게 두 가지 특성으로 분류된다:

1. **독립성(Independence)**: 다른 실행 단위에 영향을 주지 않는지 여부
2. **자원 공유(Resource Sharing)**: 메모리와 자원을 공유하는지 여부

| 단위     | 독립성 | 자원 공유 | 특징             |
| -------- | ------ | --------- | ---------------- |
| 프로세스 | ✅     | ❌        | 독립적 실행 환경 |
| 스레드   | ❌     | ✅        | 공유된 실행 환경 |

<br></br>

## 프로세스와 스레드의 본질적 차이

### 프로세스의 철학

프로세스는 **"독립적인(Independent)"** 실행 단위로 설계되었다. 이는 각각이 완전히 분리된 실행 환경을 가진다는 의미다.

**프로세스의 핵심 원칙:**

- **독립성**: 다른 프로세스와 완전히 분리된 메모리 공간
- **안정성**: 하나의 프로세스가 죽어도 다른 프로세스에 영향 없음
- **보안성**: 프로세스 간 직접적인 메모리 접근 불가
- **격리성**: 각 프로세스는 독립된 가상 주소 공간 보유

### 스레드의 철학

스레드는 **"공유하는(Shared)"** 실행 단위로, 같은 프로세스 내에서 자원을 공유하며 실행된다.

**스레드의 핵심 원칙:**

- **경량성**: 프로세스보다 생성/종료 비용이 낮음
- **공유성**: 같은 프로세스 내 메모리 영역 공유
- **협력성**: 스레드 간 빠른 데이터 교환 가능
- **효율성**: Context Switching 비용이 낮음

<br></br>

## 메모리 구조의 차이

### 프로세스의 메모리 구조

각 프로세스는 **완전히 독립된 가상 주소 공간**을 할당받는다.

```
프로세스 A                    프로세스 B
┌─────────────┐              ┌─────────────┐
│    Code     │ 0x1000       │    Code     │ 0x1000
├─────────────┤              ├─────────────┤
│    Data     │ 0x2000       │    Data     │ 0x2000
├─────────────┤              ├─────────────┤
│    Heap     │ 0x3000       │    Heap     │ 0x3000
├─────────────┤              ├─────────────┤
│    Stack    │ 0x7FFF       │    Stack    │ 0x7FFF
└─────────────┘              └─────────────┘

같은 주소여도 다른 물리 메모리를 가리킴
```

**프로세스별 메모리 영역:**

- **Code 영역**: 실행할 프로그램 코드 (읽기 전용)
- **Data 영역**: 전역 변수, 정적 변수
- **Heap 영역**: 동적 할당 메모리 (`malloc`, `new` 등)
- **Stack 영역**: 지역 변수, 함수 호출 정보

### 스레드의 메모리 구조

스레드는 **Stack 영역만 독립적**으로 할당받고, 나머지는 같은 프로세스 내 스레드들과 공유한다.

```
프로세스 (공유 영역)
┌─────────────────────────────┐
│         Code (공유)         │ ← 모든 스레드가 같은 코드 실행
├─────────────────────────────┤
│         Data (공유)         │ ← 전역 변수 공유
├─────────────────────────────┤
│         Heap (공유)         │ ← 동적 메모리 공유
├─────────────────────────────┤
│ Stack1 │ Stack2 │ Stack3 │  │ ← 각 스레드별 독립적인 Stack
└─────────────────────────────┘
Thread1  Thread2  Thread3
```

**스레드별 독립 영역:**

```c
// 각 스레드는 독립적인 Stack을 가짐
void threadFunction() {
    int localVar = 10;        // 스레드별 독립
    static int staticVar = 0; // 모든 스레드가 공유

    // localVar는 각 스레드마다 다른 Stack에 위치
    // staticVar는 Data 영역에 있어 모든 스레드가 공유
}
```

<br></br>

## 주요 특징 비교

### 1. 생성 및 종료 비용

#### 프로세스 생성 비용

프로세스 생성은 운영체제가 많은 작업을 수행해야 한다:

| 과정                 | 설명                      | 비용 |
| -------------------- | ------------------------- | ---- |
| 메모리 할당          | 독립적인 가상 주소 공간   | 높음 |
| PCB 생성             | Process Control Block     | 중간 |
| 페이지 테이블 생성   | 가상-물리 주소 매핑       | 높음 |
| 초기 메모리 설정     | Code/Data/Stack/Heap 영역 | 높음 |
| 파일 디스크립터 복사 | 부모 프로세스에서 상속    | 중간 |

#### 스레드 생성 비용

스레드 생성은 상대적으로 간단한 작업만 필요하다:

| 과정            | 설명                 | 비용 |
| --------------- | -------------------- | ---- |
| Stack 할당      | 독립적인 Stack 영역  | 낮음 |
| TCB 생성        | Thread Control Block | 낮음 |
| 레지스터 초기화 | CPU 레지스터 설정    | 낮음 |

### 2. 통신 방식

#### 프로세스 간 통신 (IPC)

프로세스는 독립된 메모리 공간 때문에 특별한 통신 방법이 필요하다:

**1. 파이프 (Pipe)**

**2. 공유 메모리 (Shared Memory)**

**3. 소켓 (Socket)**

#### 스레드 간 통신

스레드는 메모리를 공유하므로 간단한 변수 공유로 통신 가능하다.

### 3. Context Switching

#### 프로세스 Context Switching

프로세스 전환 시 많은 정보를 저장/복원해야 한다:

```
현재 프로세스 A 실행 중...

1. CPU 레지스터 저장 (PC, SP, 범용 레지스터 등)
2. 프로세스 A의 PCB에 상태 저장
3. 메모리 관리 정보 저장 (페이지 테이블 등)
4. 프로세스 B의 PCB에서 상태 복원
5. 메모리 관리 정보 복원 (페이지 테이블 교체)
6. CPU 레지스터 복원
7. 프로세스 B 실행 재개

총 소요 시간: 마이크로초 단위 (상당히 무거움)
```

#### 스레드 Context Switching

스레드 전환은 상대적으로 간단하다:

```
현재 스레드 A 실행 중...

1. CPU 레지스터 저장 (PC, SP, 범용 레지스터 등)
2. 스레드 A의 TCB에 상태 저장
3. 스레드 B의 TCB에서 상태 복원
4. CPU 레지스터 복원
5. 스레드 B 실행 재개

총 소요 시간: 나노초 단위 (상당히 가벼움)
메모리 관리 정보는 그대로 유지 (같은 프로세스 내)
```

### 4. 안정성과 격리

#### 프로세스의 안정성

```javascript
// Chrome 브라우저의 멀티프로세스 아키텍처 예시

// 각 탭이 별도 프로세스로 실행
Tab 1 Process (PID: 1234)
├── 렌더링 엔진
├── JavaScript 엔진
└── DOM 트리

Tab 2 Process (PID: 5678)
├── 렌더링 엔진
├── JavaScript 엔진
└── DOM 트리

// Tab 1에서 무한루프나 크래시 발생
Tab1: while(true) {} // CPU 100% 사용

// Tab 2는 전혀 영향받지 않음
Tab2: 정상 동작 계속...
```

**실제 Chrome에서 확인:**

```bash
# Chrome 프로세스 확인
ps aux | grep chrome
# 결과: 각 탭마다 별도의 프로세스 ID 확인 가능
```

#### 스레드의 취약성

```c
// 하나의 스레드 문제가 전체 프로세스에 영향
#include <pthread.h>

void* problematic_thread(void* arg) {
    // 널 포인터 역참조 - 세그멘테이션 폴트 발생
    int* null_ptr = NULL;
    *null_ptr = 42; // 전체 프로세스 종료!
    return NULL;
}

void* normal_thread(void* arg) {
    while(1) {
        printf("정상 스레드 실행 중...\n");
        sleep(1);
        // problematic_thread가 죽으면 이 스레드도 함께 종료됨
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, normal_thread, NULL);
    pthread_create(&thread2, NULL, problematic_thread, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL); // 여기서 전체 프로그램이 종료됨

    return 0;
}
```

### 5. 동기화 문제

#### Race Condition 예시

```c
// 스레드 간 공유 변수 접근 시 발생하는 문제
#include <pthread.h>

int counter = 0; // 공유 변수

void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        // 이 연산은 실제로 3단계로 나뉨:
        // 1. counter 값을 레지스터로 로드
        // 2. 레지스터 값을 1 증가
        // 3. 레지스터 값을 counter에 저장
        counter++; // Race Condition 발생 가능!
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, increment, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("예상 결과: 200000\n");
    printf("실제 결과: %d\n", counter); // 200000보다 작은 값 출력

    return 0;
}
```

**Race Condition 해결 - Mutex 사용:**

```c
#include <pthread.h>

int counter = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* safe_increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);   // 임계 영역 진입
        counter++;                    // 안전한 연산
        pthread_mutex_unlock(&mutex); // 임계 영역 탈출
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, safe_increment, NULL);
    pthread_create(&thread2, NULL, safe_increment, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("결과: %d\n", counter); // 항상 200000 출력

    return 0;
}
```

<br></br>

## 자주 묻는 질문 (FAQ)

### Q: 프로세스가 스레드보다 안전하다면 왜 멀티스레드를 사용하나요?

**성능과 효율성** 때문이다. 실제 시스템에서는 안정성과 성능 사이의 트레이드오프를 고려해야 한다:

```javascript
// 성능이 중요한 경우 - 웹 서버
// 수천 개의 동시 연결을 처리해야 하는 상황

// 멀티프로세스 방식 (Apache prefork)
// - 연결당 하나의 프로세스
// - 메모리 사용량: 프로세스당 ~8MB
// - 1000 연결 = 8GB 메모리 사용

// 멀티스레드 방식 (Apache worker)
// - 연결당 하나의 스레드
// - 메모리 사용량: 스레드당 ~8KB
// - 1000 연결 = 8MB 메모리 사용

// 1000배 차이!
```

**실제 Node.js의 접근법:**

```javascript
// Node.js는 이벤트 루프 + 스레드 풀 하이브리드 방식
const fs = require('fs');

// 비동기 I/O - 이벤트 루프에서 처리 (논블로킹)
fs.readFile('large-file.txt', (err, data) => {
  console.log('파일 읽기 완료');
});

// CPU 집약적 작업 - 스레드 풀에서 처리
const crypto = require('crypto');
crypto.pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, key) => {
  console.log('암호화 완료');
});
```

### Q: JavaScript는 싱글스레드인데 어떻게 동시 작업이 가능한가요?

**이벤트 루프와 비동기 처리** 메커니즘 때문이다:

```javascript
// JavaScript 실행 모델
console.log('1: 동기 실행');

setTimeout(() => {
  console.log('3: 타이머 콜백 (Web API에서 처리됨)');
}, 0);

Promise.resolve().then(() => {
  console.log('4: 마이크로태스크');
});

console.log('2: 동기 실행');

// 출력 순서: 1 → 2 → 4 → 3

// 내부 동작:
// 1. 동기 코드는 메인 스레드에서 즉시 실행
// 2. setTimeout은 별도 스레드(Timer API)에서 시간 측정
// 3. Promise는 마이크로태스크 큐에 등록
// 4. 이벤트 루프가 큐에서 작업을 가져와 실행
```

**브라우저의 실제 스레드 구조:**

```javascript
// 브라우저는 실제로 여러 스레드를 사용
Main Thread (UI Thread)
├── JavaScript 엔진 실행
├── DOM 조작
├── CSS 계산
└── 레이아웃/페인팅

Web API Threads
├── Timer 스레드 (setTimeout, setInterval)
├── HTTP 요청 스레드 (fetch, XMLHttpRequest)
├── 파일 I/O 스레드 (FileReader)
└── 웹소켓 스레드

Worker Threads
├── Web Workers (CPU 집약적 작업)
├── Service Workers (백그라운드 동기화)
└── Shared Workers (탭 간 공유)
```
